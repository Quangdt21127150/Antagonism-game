<!DOCTYPE html>
<html>
  <head>
    <title>Rank System Test - CosmosChess</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .section {
        margin: 20px 0;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
      .rank-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin: 10px 0;
      }
      .rank-card {
        border: 1px solid #ccc;
        padding: 10px;
        border-radius: 5px;
        background: #f9f9f9;
      }
      input,
      select {
        margin: 5px;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      button {
        margin: 5px;
        padding: 10px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
      }
      .btn-primary {
        background: #007bff;
        color: white;
      }
      .btn-success {
        background: #28a745;
        color: white;
      }
      .btn-warning {
        background: #ffc107;
        color: black;
      }
      .btn-danger {
        background: #dc3545;
        color: white;
      }
      .btn-info {
        background: #17a2b8;
        color: white;
      }

      pre {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        max-height: 400px;
        overflow: auto;
        border: 1px solid #e9ecef;
      }
      .status {
        padding: 10px;
        margin: 10px 0;
        border-radius: 5px;
        font-weight: bold;
      }
      .status.success {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }
      .status.error {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }
      .status.info {
        background: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
      }
      .status.warning {
        background: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üéØ Rank System Test - CosmosChess</h1>

      <!-- Connection Section -->
      <div class="section">
        <h3>üîå K·∫øt n·ªëi</h3>
        <label
          >JWT Token:
          <input
            id="tokenInput"
            size="80"
            placeholder="Nh·∫≠p JWT token..." /></label
        ><br />
        <label
          >User ID:
          <input
            id="userIdInput"
            size="50"
            placeholder="Nh·∫≠p User ID..." /></label
        ><br />
        <button class="btn-primary" onclick="connect()">üîå K·∫øt n·ªëi</button>
        <button class="btn-danger" onclick="disconnect()">
          ‚ùå Ng·∫Øt k·∫øt n·ªëi
        </button>
        <div id="connectionStatus"></div>
      </div>

      <!-- User Info Section -->
      <div class="section">
        <h3>üë§ Th√¥ng tin ng∆∞·ªùi ch∆°i</h3>
        <button class="btn-info" onclick="getUserInfo()">
          üìä L·∫•y th√¥ng tin
        </button>
        <div id="userInfo"></div>
      </div>

      <!-- Rank System Info -->
      <div class="section">
        <h3>üèÜ H·ªá th·ªëng Rank</h3>
        <div class="rank-info">
          <div class="rank-card">
            <strong>C·∫•p 1 - Nam T∆∞·ªõc</strong><br />
            ELO: 0-500<br />
            L·ªá ph√≠: 1 gem<br />
            ƒêi·ªÅu ki·ªán: 10+ tr·∫≠n, 60% th·∫Øng
          </div>
          <div class="rank-card">
            <strong>C·∫•p 2 - T·ª≠ T∆∞·ªõc</strong><br />
            ELO: 501-1100<br />
            L·ªá ph√≠: 2 gem<br />
            ƒêi·ªÅu ki·ªán: 20+ tr·∫≠n, 60% th·∫Øng
          </div>
          <div class="rank-card">
            <strong>C·∫•p 3 - B√† T∆∞·ªõc</strong><br />
            ELO: 1101-1500<br />
            L·ªá ph√≠: 4 gem<br />
            ƒêi·ªÅu ki·ªán: 40+ tr·∫≠n, 60% th·∫Øng
          </div>
          <div class="rank-card">
            <strong>C·∫•p 4 - H·∫ßu T∆∞·ªõc</strong><br />
            ELO: 1501-2100<br />
            L·ªá ph√≠: 8 gem<br />
            ƒêi·ªÅu ki·ªán: 80+ tr·∫≠n, 60% th·∫Øng
          </div>
          <div class="rank-card">
            <strong>C·∫•p 5 - C√¥ng T∆∞·ªõc</strong><br />
            ELO: 2101-2900<br />
            L·ªá ph√≠: 16 gem<br />
            ƒêi·ªÅu ki·ªán: 160+ tr·∫≠n, 60% th·∫Øng
          </div>
          <div class="rank-card">
            <strong>C·∫•p 6 - V∆∞∆°ng T∆∞·ªõc</strong><br />
            ELO: 2901-4000<br />
            L·ªá ph√≠: 32 gem<br />
            ƒêi·ªÅu ki·ªán: 320+ tr·∫≠n, 60% th·∫Øng
          </div>
          <div class="rank-card">
            <strong>C·∫•p 7 - Ho√†ng ƒê·∫ø</strong><br />
            ELO: 4000+<br />
            L·ªá ph√≠: 64 gem<br />
            ƒêi·ªÅu ki·ªán: 640+ tr·∫≠n, 60% th·∫Øng
          </div>
        </div>
      </div>

      <!-- Match Finding Test -->
      <div class="section">
        <h3>üéØ Test t√¨m tr·∫≠n</h3>
        <label
          >Th·ªùi gian ch·ªù (ph√∫t):
          <input
            id="waitTimeInput"
            type="number"
            value="0"
            min="0"
            step="0.5" /></label
        ><br />
        <button class="btn-success" onclick="findMatch()">üéØ T√¨m tr·∫≠n</button>
        <button class="btn-warning" onclick="cancelFindMatch()">
          ‚èπÔ∏è H·ªßy t√¨m
        </button>
        <button class="btn-danger" onclick="resign()">üõë ƒê·∫ßu h√†ng</button>
        <div id="matchStatus"></div>
      </div>

      <!-- Test Cases -->
      <div class="section">
        <h3>üß™ Test Cases</h3>
        <button class="btn-info" onclick="testRankCalculation()">
          üìä Test t√≠nh rank
        </button>
        <button class="btn-info" onclick="testEloRange()">
          üéØ Test kho·∫£ng ELO
        </button>
        <button class="btn-info" onclick="testRankFee()">üí∞ Test l·ªá ph√≠</button>
        <button class="btn-info" onclick="testHiddenPromotion()">
          ‚≠ê Test ƒëi·ªÅu ki·ªán ·∫©n
        </button>
        <div id="testResults"></div>
      </div>

      <!-- Log -->
      <div class="section">
        <h3>üìù Log</h3>
        <pre id="log"></pre>
      </div>
    </div>

    <script>
      let socket,
        userId,
        currentUser = null;
      let isFindingMatch = false;

      function log(...args) {
        const msg = args
          .map((a) => (typeof a === "object" ? JSON.stringify(a, null, 2) : a))
          .join(" ");
        const timestamp = new Date().toLocaleTimeString();
        document.getElementById("log").textContent += `\n[${timestamp}] ${msg}`;
        console.log(...args);
      }

      function showStatus(elementId, message, type = "info") {
        const element = document.getElementById(elementId);
        element.innerHTML = `<div class="status ${type}">${message}</div>`;
      }

      function connect() {
        const token = document.getElementById("tokenInput").value;
        userId = document.getElementById("userIdInput").value;

        if (!token || !userId) {
          showStatus(
            "connectionStatus",
            "‚ùå Vui l√≤ng nh·∫≠p JWT token v√† User ID",
            "error"
          );
          return;
        }

        socket = io("http://localhost:3000", { auth: { token } });

        socket.on("connect", () => {
          log("‚úÖ ƒê√£ k·∫øt n·ªëi:", socket.id);
          showStatus(
            "connectionStatus",
            `‚úÖ ƒê√£ k·∫øt n·ªëi th√†nh c√¥ng - Socket ID: ${socket.id}`,
            "success"
          );
        });

        socket.on("disconnect", () => {
          log("‚ùå ƒê√£ ng·∫Øt k·∫øt n·ªëi");
          showStatus("connectionStatus", "‚ùå ƒê√£ ng·∫Øt k·∫øt n·ªëi", "error");
        });

        socket.on("connect_error", (err) => {
          log("‚ùó L·ªói k·∫øt n·ªëi:", err.message);
          showStatus(
            "connectionStatus",
            `‚ùó L·ªói k·∫øt n·ªëi: ${err.message}`,
            "error"
          );
        });

        socket.on("match_found", (data) => {
          log("üéØ ƒê√£ t√¨m th·∫•y tr·∫≠n ƒë·∫•u:", data);
          showStatus(
            "matchStatus",
            `üéØ ƒê√£ t√¨m th·∫•y tr·∫≠n ƒë·∫•u! Match ID: ${data.matchId}`,
            "success"
          );
          isFindingMatch = false;
        });

        socket.on("start_turn", (data) => {
          log(`üîÅ Turn: ${data.turn}`);
        });

        socket.on("opponent_moved", (data) => {
          log("üì¶ Opponent moved:", data);
        });

        socket.on("piece_captured", (data) => {
          log("üí• Piece captured:", data);
        });

        socket.on("game_over", (data) => {
          log("üèÅ Game Over!", data);
          showStatus(
            "matchStatus",
            `üèÅ Game Over! Winner: ${data.winner}`,
            "success"
          );
        });

        socket.on("error", (err) => {
          const message = typeof err === "string" ? err : err.message;
          log("‚ö†Ô∏è L·ªói:", message);
          showStatus("matchStatus", `‚ö†Ô∏è L·ªói: ${message}`, "error");
          isFindingMatch = false;
        });
      }

      function disconnect() {
        if (socket && socket.connected) {
          socket.disconnect();
          log("üßπ ƒê√£ ng·∫Øt k·∫øt n·ªëi th·ªß c√¥ng");
        } else {
          log("‚ö†Ô∏è Kh√¥ng c√≥ k·∫øt n·ªëi ƒë·ªÉ ng·∫Øt");
        }
      }

      async function getUserInfo() {
        if (!userId) {
          showStatus("userInfo", "‚ùå Vui l√≤ng nh·∫≠p User ID", "error");
          return;
        }

        try {
          const response = await fetch(
            `http://localhost:3000/api/users/profile`,
            {
              headers: {
                Authorization: `Bearer ${
                  document.getElementById("tokenInput").value
                }`,
              },
            }
          );

          if (response.ok) {
            const data = await response.json();
            currentUser = data; // API tr·∫£ v·ªÅ tr·ª±c ti·∫øp user object

            const rankLevel = getRankLevel(currentUser.elo);
            const rankFee = getRankFee(currentUser.elo);

            const userInfoHtml = `
               <div class="rank-card">
                 <strong>Th√¥ng tin ng∆∞·ªùi ch∆°i:</strong><br>
                 Username: ${currentUser.username}<br>
                 ELO: ${currentUser.elo}<br>
                 C·∫•p ƒë·ªô: ${rankLevel}<br>
                 L·ªá ph√≠: ${rankFee} gem<br>
                 Gem hi·ªán t·∫°i: ${currentUser.gem}<br>
                 T·ªïng tr·∫≠n: ${currentUser.total_matches || 0}<br>
                 T·ªâ l·ªá th·∫Øng: ${((currentUser.win_rate || 0) * 100).toFixed(
                   1
                 )}%<br>
                 <strong>Tr·∫°ng th√°i:</strong> ${
                   currentUser.gem >= rankFee
                     ? "‚úÖ ƒê·ªß gem ƒë·ªÉ ch∆°i"
                     : "‚ùå Thi·∫øu gem"
                 }
               </div>
             `;

            document.getElementById("userInfo").innerHTML = userInfoHtml;
            log("üìä Th√¥ng tin ng∆∞·ªùi ch∆°i:", data);
          } else {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP ${response.status}`);
          }
        } catch (error) {
          log("‚ùå L·ªói l·∫•y th√¥ng tin:", error.message);
          showStatus("userInfo", `‚ùå L·ªói: ${error.message}`, "error");
        }
      }

      function findMatch() {
        if (!socket || !socket.connected) {
          showStatus("matchStatus", "‚ùå Ch∆∞a k·∫øt n·ªëi", "error");
          return;
        }

        if (!currentUser) {
          showStatus(
            "matchStatus",
            "‚ùå Vui l√≤ng l·∫•y th√¥ng tin ng∆∞·ªùi ch∆°i tr∆∞·ªõc",
            "error"
          );
          return;
        }

        const waitTime = parseFloat(
          document.getElementById("waitTimeInput").value
        );
        const rankLevel = getRankLevel(currentUser.elo);
        const rankFee = getRankFee(currentUser.elo);

        if (currentUser.gem < rankFee) {
          showStatus(
            "matchStatus",
            `‚ùå Kh√¥ng ƒë·ªß gem! C·∫ßn ${rankFee} gem cho c·∫•p ${rankLevel}`,
            "error"
          );
          return;
        }

        socket.emit("find_match", { userId });
        isFindingMatch = true;

        showStatus(
          "matchStatus",
          `üîç ƒêang t√¨m tr·∫≠n... (C·∫•p ${rankLevel}, L·ªá ph√≠: ${rankFee} gem)`,
          "info"
        );
        log(
          `üîç B·∫Øt ƒë·∫ßu t√¨m tr·∫≠n - User: ${userId}, C·∫•p: ${rankLevel}, L·ªá ph√≠: ${rankFee} gem`
        );
      }

      function cancelFindMatch() {
        if (socket && socket.connected) {
          socket.emit("cancel_find_match", { userId });
          isFindingMatch = false;
          showStatus("matchStatus", "‚èπÔ∏è ƒê√£ h·ªßy t√¨m tr·∫≠n", "warning");
          log("‚èπÔ∏è ƒê√£ h·ªßy t√¨m tr·∫≠n");
        }
      }

      function resign() {
        if (!socket || !socket.connected) {
          showStatus("matchStatus", "‚ùå Ch∆∞a k·∫øt n·ªëi", "error");
          return;
        }

        socket.emit("resign", { userId });
        showStatus("matchStatus", "üõë ƒê√£ ƒë·∫ßu h√†ng", "warning");
        log("üõë ƒê√£ ƒë·∫ßu h√†ng");
      }

      // Helper functions for testing
      function getRankLevel(elo) {
        const ranks = [
          { level: 1, minElo: 0, maxElo: 500 },
          { level: 2, minElo: 501, maxElo: 1100 },
          { level: 3, minElo: 1101, maxElo: 1500 },
          { level: 4, minElo: 1501, maxElo: 2100 },
          { level: 5, minElo: 2101, maxElo: 2900 },
          { level: 6, minElo: 2901, maxElo: 4000 },
          { level: 7, minElo: 4001, maxElo: Infinity },
        ];
        return (
          ranks.find((r) => elo >= r.minElo && elo <= r.maxElo)?.level || 1
        );
      }

      function getRankFee(elo) {
        const ranks = [
          { level: 1, minElo: 0, maxElo: 500, fee: 1 },
          { level: 2, minElo: 501, maxElo: 1100, fee: 2 },
          { level: 3, minElo: 1101, maxElo: 1500, fee: 4 },
          { level: 4, minElo: 1501, maxElo: 2100, fee: 8 },
          { level: 5, minElo: 2101, maxElo: 2900, fee: 16 },
          { level: 6, minElo: 2901, maxElo: 4000, fee: 32 },
          { level: 7, minElo: 4001, maxElo: Infinity, fee: 64 },
        ];
        return ranks.find((r) => elo >= r.minElo && elo <= r.maxElo)?.fee || 1;
      }

      function testRankCalculation() {
        const testCases = [
          { elo: 0, expectedLevel: 1 },
          { elo: 500, expectedLevel: 1 },
          { elo: 501, expectedLevel: 2 },
          { elo: 1100, expectedLevel: 2 },
          { elo: 1101, expectedLevel: 3 },
          { elo: 1500, expectedLevel: 3 },
          { elo: 1501, expectedLevel: 4 },
          { elo: 2100, expectedLevel: 4 },
          { elo: 2101, expectedLevel: 5 },
          { elo: 2900, expectedLevel: 5 },
          { elo: 2901, expectedLevel: 6 },
          { elo: 4000, expectedLevel: 6 },
          { elo: 4001, expectedLevel: 7 },
          { elo: 5000, expectedLevel: 7 },
        ];

        let results = "üìä Test t√≠nh rank:\n";
        testCases.forEach((test) => {
          const actualLevel = getRankLevel(test.elo);
          const status = actualLevel === test.expectedLevel ? "‚úÖ" : "‚ùå";
          results += `${status} ELO ${test.elo} -> C·∫•p ${actualLevel} (mong ƒë·ª£i: ${test.expectedLevel})\n`;
        });

        log(results);
        showStatus("testResults", results.replace(/\n/g, "<br>"), "info");
      }

      function testEloRange() {
        const testCases = [
          { level: 1, waitMinutes: 0, expectedRange: [0, 500] },
          { level: 1, waitMinutes: 1.5, expectedRange: [0, 1100] },
          { level: 1, waitMinutes: 5, expectedRange: [0, 1500] },
          { level: 4, waitMinutes: 0, expectedRange: [1501, 2100] },
          { level: 4, waitMinutes: 1.5, expectedRange: [1101, 2900] },
          { level: 4, waitMinutes: 5, expectedRange: [501, 4000] },
          { level: 7, waitMinutes: 0, expectedRange: [4001, 3000] },
          { level: 7, waitMinutes: 1.5, expectedRange: [2901, 3000] },
          { level: 7, waitMinutes: 5, expectedRange: [2101, 3000] },
        ];

        let results = "üéØ Test kho·∫£ng ELO:\n";
        testCases.forEach((test) => {
          // Simulate getEloRangeFromLevel logic
          let widenLevels = 0;
          if (test.waitMinutes >= 1.5) widenLevels = 1;
          if (test.waitMinutes >= 5) widenLevels = 2;

          const minLevel = Math.max(1, test.level - widenLevels);
          const maxLevel = Math.min(7, test.level + widenLevels);

          const ranks = [
            { level: 1, minElo: 0, maxElo: 500 },
            { level: 2, minElo: 501, maxElo: 1100 },
            { level: 3, minElo: 1101, maxElo: 1500 },
            { level: 4, minElo: 1501, maxElo: 2100 },
            { level: 5, minElo: 2101, maxElo: 2900 },
            { level: 6, minElo: 2901, maxElo: 4000 },
            { level: 7, minElo: 4001, maxElo: Infinity },
          ];

          const minElo = ranks.find((r) => r.level === minLevel)?.minElo ?? 0;
          const maxElo =
            ranks.find((r) => r.level === maxLevel)?.maxElo ?? 3000;

          const actualRange = [minElo, maxElo];
          const status =
            JSON.stringify(actualRange) === JSON.stringify(test.expectedRange)
              ? "‚úÖ"
              : "‚ùå";
          results += `${status} C·∫•p ${test.level}, ch·ªù ${test.waitMinutes}p -> [${actualRange[0]}, ${actualRange[1]}]\n`;
        });

        log(results);
        showStatus("testResults", results.replace(/\n/g, "<br>"), "info");
      }

      function testRankFee() {
        const testCases = [
          { elo: 0, expectedFee: 1 },
          { elo: 500, expectedFee: 1 },
          { elo: 501, expectedFee: 2 },
          { elo: 1100, expectedFee: 2 },
          { elo: 1101, expectedFee: 4 },
          { elo: 1500, expectedFee: 4 },
          { elo: 1501, expectedFee: 8 },
          { elo: 2100, expectedFee: 8 },
          { elo: 2101, expectedFee: 16 },
          { elo: 2900, expectedFee: 16 },
          { elo: 2901, expectedFee: 32 },
          { elo: 4000, expectedFee: 32 },
          { elo: 4001, expectedFee: 64 },
          { elo: 5000, expectedFee: 64 },
        ];

        let results = "üí∞ Test l·ªá ph√≠:\n";
        testCases.forEach((test) => {
          const actualFee = getRankFee(test.elo);
          const status = actualFee === test.expectedFee ? "‚úÖ" : "‚ùå";
          results += `${status} ELO ${test.elo} -> ${actualFee} gem (mong ƒë·ª£i: ${test.expectedFee})\n`;
        });

        log(results);
        showStatus("testResults", results.replace(/\n/g, "<br>"), "info");
      }

      function testHiddenPromotion() {
        const testCases = [
          {
            user: { total_matches: 5, win_rate: 0.7 },
            level: 1,
            expected: false,
            description: "√çt tr·∫≠n (5 < 10)",
          },
          {
            user: { total_matches: 15, win_rate: 0.5 },
            level: 1,
            expected: false,
            description: "T·ªâ l·ªá th·∫Øng th·∫•p (0.5 < 0.6)",
          },
          {
            user: { total_matches: 15, win_rate: 0.7 },
            level: 1,
            expected: true,
            description: "ƒê·ªß ƒëi·ªÅu ki·ªán l√™n c·∫•p 2",
          },
          {
            user: { total_matches: 25, win_rate: 0.8 },
            level: 2,
            expected: true,
            description: "ƒê·ªß ƒëi·ªÅu ki·ªán l√™n c·∫•p 3",
          },
        ];

        let results = "‚≠ê Test ƒëi·ªÅu ki·ªán ·∫©n:\n";
        testCases.forEach((test) => {
          // Simulate checkHiddenPromotion logic
          const nextLevel = test.level + 1;
          const hiddenConditions = {
            2: (user) => user.total_matches >= 10 && user.win_rate >= 0.6,
            3: (user) => user.total_matches >= 20 && user.win_rate >= 0.6,
            4: (user) => user.total_matches >= 40 && user.win_rate >= 0.6,
            5: (user) => user.total_matches >= 80 && user.win_rate >= 0.6,
            6: (user) => user.total_matches >= 160 && user.win_rate >= 0.6,
            7: (user) => user.total_matches >= 320 && user.win_rate >= 0.6,
          };

          const condition = hiddenConditions[nextLevel];
          const actual = condition ? condition(test.user) : false;
          const status = actual === test.expected ? "‚úÖ" : "‚ùå";
          results += `${status} ${test.description} -> ${
            actual ? "C√≥ th·ªÉ l√™n c·∫•p" : "Kh√¥ng th·ªÉ l√™n c·∫•p"
          }\n`;
        });

        log(results);
        showStatus("testResults", results.replace(/\n/g, "<br>"), "info");
      }
    </script>
  </body>
</html>
